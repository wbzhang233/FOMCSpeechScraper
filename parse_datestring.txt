#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
@File    :   common.py
@Time    :   2024/09/29 17:42:47
@Author  :   wbzhang
@Version :   1.0
@Desc    :   公共方法
"""

from datetime import datetime
import re

date_patterns = [
    r"""
^(January|February|March|April|May|June|July|August|September|October|November|December)\s+  # 月份
(\d{1,2}),\s+  # 日，带逗号
(\d{4})$       # 年份
""",  # %B %d, %Y
    r"""
^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Sept|Oct|Nov|Dec)\s+  # 月份
(\d{1,2}),\s+  # 日，带逗号
(\d{4})$       # 年份
""",  # %b %d, %Y
    r"""
^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Sept|Oct|Nov|Dec).\s+  # 月份
(\d{1,2}),\s+  # 日，带逗号
(\d{4})$       # 年份
""",  # %b. %d, %Y
]


def parse_datestring(date_str: str) -> datetime.date:
    """日期字符串标准化

    Args:
        date_str (_type_): _description_

    Returns:
        _type_: _description_
    """
    if not date_str:
        return None
    try:
        if re.fullmatch(date_patterns[0], date_str, re.IGNORECASE | re.VERBOSE):
            return datetime.strptime(date_str, "%B %d, %Y")
        elif re.fullmatch(date_patterns[1], date_str, re.IGNORECASE | re.VERBOSE):
            date_str = date_str.replace('Sept', 'Sep').replace('sept', 'sep')
            return datetime.strptime(date_str, "%b %d, %Y")
        elif re.fullmatch(date_patterns[2], date_str, re.IGNORECASE | re.VERBOSE):
            date_str = date_str.replace("Sept", "Sep").replace("sept", "sep")
            return datetime.strptime(date_str, "%b. %d, %Y")
        else:
            return date_str
    except ValueError as e:
        print(date_str + f" | {repr(e)}")
        return date_str
    except Exception as e:
        print(date_str + f" | {repr(e)}")
        return date_str


# def stardard_datestring(date_str: str) -> str:
#     return parse_datestring(date_str).strftime("%Y-%m-%d")

if __name__ == "__main__":
    dates = []
    for year_str in [
        "Sep 23, 2024",
        "Oct 23, 1995",
        "Sept 23, 2024",
        "Sept. 25, 2024" , 
        "May 06, 2024",
        "March 20, 1997",
    ]:
        date = parse_datestring(year_str)
        print(date)
        dates.append(date)
    print(max(dates))

#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
@File    :   file_saver.py
@Time    :   2024/10/12 11:24:06
@Author  :   wbzhang
@Version :   1.0
@Desc    :   JSON文件存储、读取与更新
"""

import json

from utils.logger import logger


def json_dump(obj, filepath: str):
    try:
        with open(filepath, "w", encoding="utf-8") as f:
            json.dump(obj, f, ensure_ascii=False, indent=4)
    except Exception as e:
        print(f"Error writing to file: {e}")


def json_load(filepath: str):
    """加载json文件

    Args:
        filepath (str): _description_

    Returns:
        _type_: _description_
    """
    try:
        with open(filepath, "r", encoding="utf-8") as f:
            obj = json.load(f)
        return obj
    except FileNotFoundError:
        print(f"Error. file {filepath} not found.")
        return None
    except json.JSONDecodeError:
        print(f"Error. file {filepath} is not in valid json format.")
        return None
    except Exception as e:
        print(f"Error load file {filepath}: {e}")
        return None


def records_update(records: list[dict], new: list[dict],
                   tag_fields: list[str] = None, sort_field: str= 'date'):
    """对records格式的list进行去重
    Args:
        records (list[dict]): list[dict]格式的变量
        tag_field (str): 每个元素的标签元素

    
    """
    if not tag_fields:
        tag_fields = ['speaker', 'date', 'title']
    records.extend(new)
    try:
        # 使用字典去重，确保每个 field 只出现一次
        unique_data = {}
        for item in records:
            tag = " ".join([str(item[field]) for field in tag_fields])
            unique_data[tag] = item

        # 将去重后的字典转换回列表
        unique_list = list(unique_data.values())

        # 使用 `sorted()` 函数根据 `date` 字段进行升序排序
        sorted_records = sorted(unique_list, key=lambda x: x[sort_field])
        return sorted_records
    except Exception as e:
        msg = f"Records update failed. Error: {repr(e)}"
        logger.warning(msg)
        return records

def json_update(filepath: str, obj, **kwargs):
    """更新已存储的json文件

    Args:
        filepath (str): _description_
    """
    exist_obj = json_load(filepath)
    if isinstance(exist_obj, dict):
        for k, v in obj.items():
            if k in exist_obj:
                exist_obj[k] = records_update(exist_obj[k], v, **kwargs)
                logger.info(f"{k} updated.")
            else:
                exist_obj[k] = v
        json_dump(exist_obj, filepath)
    elif isinstance(exist_obj, list):
        exist_obj = records_update(exist_obj, obj, **kwargs)
        json_dump(exist_obj, filepath)
    else:
        msg = f"JSON update failed. Unknown object type: {type(exist_obj)}"
        logger.error(msg)


def test_json_load():
    json_data = json_load(
        "../data/fed_speeches/boston_fed_speeches/boston_fed_speech_infos.json"
    )
    if json_data is not None:
        print(json_data)
        print("Succeed.")


if __name__ == "__main__":
    test_json_load()


import logging

# 创建一个logger
logger = logging.getLogger("ScraperLogger")
logger.setLevel(logging.DEBUG)

# 创建一个handler，用于写入日志文件
fh = logging.FileHandler("app.log")
fh.setLevel(logging.DEBUG)

# 再创建一个handler，用于输出到控制台
ch = logging.StreamHandler()
ch.setLevel(logging.ERROR)

# 定义handler的输出格式
formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
fh.setFormatter(formatter)
ch.setFormatter(formatter)

# 给logger添加handler
logger.addHandler(fh)
logger.addHandler(ch)


